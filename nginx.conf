worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format video_requests_log '[$time_local] $remote_addr requested $uri '
                                  'Range="$http_range" -> cache=$upstream_cache_status';
    access_log /var/log/nginx/video_access.log video_requests_log;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout 65;

    proxy_cache_path /var/cache/nginx/video_cache levels=1:2 keys_zone=video_cache:100m inactive=10m max_size=5g use_temp_path=off;

    server {
        listen 8081;
        server_name localhost;

        # Mirror to Python for analysis/storage
        location /mirror-push {
            internal;  # Prevent direct access
            proxy_pass http://host.docker.internal:2324/push;  # Python must run server at /push
            proxy_set_header Content-Length $content_length;
            proxy_set_header Content-Type $content_type;
            proxy_set_body $request_body;
        }

        location /videos/ {
            proxy_pass http://host.docker.internal:8080/;
            proxy_cache video_cache;
            proxy_cache_key "$uri$http_range";
            proxy_cache_valid 200 206 10m;
            proxy_cache_min_uses 1;
            proxy_cache_bypass $arg_new_video;
            proxy_no_cache $arg_new_video;

            proxy_cache_lock on;
            proxy_cache_lock_timeout 5s;
            proxy_ignore_headers "Cache-Control" "Expires";
            proxy_set_header Range $http_range;
            proxy_set_header If-Range $http_if_range;

            add_header X-Cache-Status $upstream_cache_status always;

            # Mirror every request (and body) to Python
            #mirror /mirror-push;
        }
    }
}
